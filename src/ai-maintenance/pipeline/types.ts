/**
 * Types for the Adaptation Pipeline
 * @module ai-maintenance/pipeline/types
 */

import {
  AdaptationPipeline,
  PipelineStage,
  StageTransition,
  RepositoryChange,
  AnalysisResult,
  ChangeProposal,
  ValidationResult,
  DeploymentResult,
  PipelineError,
} from '../types';

/**
 * Configuration for the adaptation pipeline
 */
export interface PipelineConfig {
  /** Auto-approve proposals below this impact score */
  autoApprovalThreshold: number;
  /** Require human approval for proposals above this impact score */
  humanApprovalThreshold: number;
  /** Maximum concurrent pipelines */
  maxConcurrentPipelines: number;
  /** Pipeline timeout in milliseconds */
  pipelineTimeoutMs: number;
  /** Enable dry-run mode (no actual deployments) */
  dryRun: boolean;
  /** Deployment strategy */
  deploymentStrategy: 'direct' | 'canary' | 'blue-green';
  /** Canary percentage (if using canary deployment) */
  canaryPercentage: number;
  /** Enable automatic rollback on failure */
  autoRollback: boolean;
  /** Notification webhook URL */
  notificationWebhook?: string;
  /** Git configuration */
  git: GitConfig;
}

/**
 * Git configuration for deployments
 */
export interface GitConfig {
  /** Remote name */
  remote: string;
  /** Target branch for PRs */
  targetBranch: string;
  /** Branch prefix for generated changes */
  branchPrefix: string;
  /** Commit message template */
  commitTemplate: string;
  /** Create PR instead of direct push */
  createPullRequest: boolean;
}

/**
 * Pipeline event types
 */
export interface PipelineEvents {
  'pipeline:created': (pipeline: AdaptationPipeline) => void;
  'pipeline:stage-changed': (pipeline: AdaptationPipeline, transition: StageTransition) => void;
  'pipeline:completed': (pipeline: AdaptationPipeline) => void;
  'pipeline:failed': (pipeline: AdaptationPipeline, error: PipelineError) => void;
  'pipeline:approval-required': (pipeline: AdaptationPipeline, proposal: ChangeProposal) => void;
  'change:detected': (change: RepositoryChange) => void;
  'analysis:completed': (result: AnalysisResult) => void;
  'proposal:generated': (proposal: ChangeProposal) => void;
  'validation:completed': (result: ValidationResult) => void;
  'deployment:completed': (result: DeploymentResult) => void;
}

/**
 * Human review decision
 */
export interface ReviewDecision {
  approved: boolean;
  reviewerId: string;
  comments?: string;
  modifications?: string[];
  timestamp: string;
}

/**
 * Pipeline orchestrator state
 */
export interface OrchestratorState {
  activePipelines: Map<string, AdaptationPipeline>;
  pendingApprovals: Map<string, ChangeProposal>;
  completedPipelines: AdaptationPipeline[];
  statistics: PipelineStatistics;
}

/**
 * Pipeline statistics
 */
export interface PipelineStatistics {
  totalPipelinesRun: number;
  successfulPipelines: number;
  failedPipelines: number;
  averageDurationMs: number;
  autoApprovedCount: number;
  humanApprovedCount: number;
  rejectedCount: number;
  rollbackCount: number;
}

/**
 * Default pipeline configuration
 */
export const DEFAULT_PIPELINE_CONFIG: PipelineConfig = {
  autoApprovalThreshold: 0.3,
  humanApprovalThreshold: 0.7,
  maxConcurrentPipelines: 3,
  pipelineTimeoutMs: 30 * 60 * 1000, // 30 minutes
  dryRun: false,
  deploymentStrategy: 'direct',
  canaryPercentage: 10,
  autoRollback: true,
  git: {
    remote: 'origin',
    targetBranch: 'main',
    branchPrefix: 'ai-adapt/',
    commitTemplate: 'chore(adapters): {{title}}\n\n{{description}}\n\nGenerated by AI-Led Adaptive Maintenance System',
    createPullRequest: true,
  },
};

/**
 * Create initial orchestrator state
 */
export function createInitialState(): OrchestratorState {
  return {
    activePipelines: new Map(),
    pendingApprovals: new Map(),
    completedPipelines: [],
    statistics: {
      totalPipelinesRun: 0,
      successfulPipelines: 0,
      failedPipelines: 0,
      averageDurationMs: 0,
      autoApprovedCount: 0,
      humanApprovedCount: 0,
      rejectedCount: 0,
      rollbackCount: 0,
    },
  };
}
