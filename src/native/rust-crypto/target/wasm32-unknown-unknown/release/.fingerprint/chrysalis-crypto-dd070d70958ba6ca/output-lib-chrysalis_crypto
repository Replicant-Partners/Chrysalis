{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":10580,"byte_end":10594,"line_start":347,"line_end":347,"column_start":31,"column_end":45,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha256::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":31,"highlight_end":45}],"label":"multiple `new_from_slice` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `KeyInit` for the type `CoreWrapper<T>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `Mac` for the type `T`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":10568,"byte_end":10580,"line_start":347,"line_end":347,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha256::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":"<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha256VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, OidSha256>>>> as KeyInit>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/lib.rs","byte_start":10568,"byte_end":10580,"line_start":347,"line_end":347,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha256::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":"<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha256VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, OidSha256>>>> as Mac>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0034]\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:347:31\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m347\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let mut mac = HmacSha256::new_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmultiple `new_from_slice` found\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: candidate #1 is defined in an impl of the trait `KeyInit` for the type `CoreWrapper<T>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: candidate #2 is defined in an impl of the trait `Mac` for the type `T`\n\u001b[1m\u001b[96mhelp\u001b[0m: use fully-qualified syntax to disambiguate\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m347\u001b[0m \u001b[91m- \u001b[0m    let mut mac = \u001b[91mHmacSha256::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n\u001b[1m\u001b[94m347\u001b[0m \u001b[92m+ \u001b[0m    let mut mac = \u001b[92m<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha256VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, OidSha256>>>> as KeyInit>::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m347\u001b[0m \u001b[91m- \u001b[0m    let mut mac = \u001b[91mHmacSha256::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n\u001b[1m\u001b[94m347\u001b[0m \u001b[92m+ \u001b[0m    let mut mac = \u001b[92m<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha256VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, OidSha256>>>> as Mac>::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":10851,"byte_end":10865,"line_start":356,"line_end":356,"column_start":31,"column_end":45,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha384::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":31,"highlight_end":45}],"label":"multiple `new_from_slice` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `KeyInit` for the type `CoreWrapper<T>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `Mac` for the type `T`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":10839,"byte_end":10851,"line_start":356,"line_end":356,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha384::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":"<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, OidSha384>>>> as KeyInit>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/lib.rs","byte_start":10839,"byte_end":10851,"line_start":356,"line_end":356,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha384::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":"<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, OidSha384>>>> as Mac>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0034]\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:356:31\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m356\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let mut mac = HmacSha384::new_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmultiple `new_from_slice` found\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: candidate #1 is defined in an impl of the trait `KeyInit` for the type `CoreWrapper<T>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: candidate #2 is defined in an impl of the trait `Mac` for the type `T`\n\u001b[1m\u001b[96mhelp\u001b[0m: use fully-qualified syntax to disambiguate\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m356\u001b[0m \u001b[91m- \u001b[0m    let mut mac = \u001b[91mHmacSha384::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n\u001b[1m\u001b[94m356\u001b[0m \u001b[92m+ \u001b[0m    let mut mac = \u001b[92m<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, OidSha384>>>> as KeyInit>::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m356\u001b[0m \u001b[91m- \u001b[0m    let mut mac = \u001b[91mHmacSha384::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n\u001b[1m\u001b[94m356\u001b[0m \u001b[92m+ \u001b[0m    let mut mac = \u001b[92m<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>, B0>, B0>, B0>, OidSha384>>>> as Mac>::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11122,"byte_end":11136,"line_start":365,"line_end":365,"column_start":31,"column_end":45,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha512::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":31,"highlight_end":45}],"label":"multiple `new_from_slice` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in an impl of the trait `KeyInit` for the type `CoreWrapper<T>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"candidate #2 is defined in an impl of the trait `Mac` for the type `T`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use fully-qualified syntax to disambiguate","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":11110,"byte_end":11122,"line_start":365,"line_end":365,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha512::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":"<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, OidSha512>>>> as KeyInit>::","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/lib.rs","byte_start":11110,"byte_end":11122,"line_start":365,"line_end":365,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"    let mut mac = HmacSha512::new_from_slice(key).expect(\"HMAC accepts any key length\");","highlight_start":19,"highlight_end":31}],"label":null,"suggested_replacement":"<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, OidSha512>>>> as Mac>::","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0034]\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:365:31\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m365\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let mut mac = HmacSha512::new_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmultiple `new_from_slice` found\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: candidate #1 is defined in an impl of the trait `KeyInit` for the type `CoreWrapper<T>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: candidate #2 is defined in an impl of the trait `Mac` for the type `T`\n\u001b[1m\u001b[96mhelp\u001b[0m: use fully-qualified syntax to disambiguate\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m365\u001b[0m \u001b[91m- \u001b[0m    let mut mac = \u001b[91mHmacSha512::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n\u001b[1m\u001b[94m365\u001b[0m \u001b[92m+ \u001b[0m    let mut mac = \u001b[92m<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, OidSha512>>>> as KeyInit>::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m365\u001b[0m \u001b[91m- \u001b[0m    let mut mac = \u001b[91mHmacSha512::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n\u001b[1m\u001b[94m365\u001b[0m \u001b[92m+ \u001b[0m    let mut mac = \u001b[92m<CoreWrapper<HmacCore<CoreWrapper<CtVariableCoreWrapper<Sha512VarCore, UInt<UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>, B0>, OidSha512>>>> as Mac>::\u001b[0mnew_from_slice(key).expect(\"HMAC accepts any key length\");\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0034`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about this error, try `rustc --explain E0034`.\u001b[0m\n"}
